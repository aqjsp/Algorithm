## 反转链表

LeetCode.206

大家好，我是阿Q。

今天继续给大家讲解**《经典面试题系列》**之**反转链表**，其实这是一道还算简单的题目，不过在面试中还是经常会被问到，有没有小伙伴被绕晕了哈哈。

没关系，今天我带大家一起重温一下这个很经典的题目。最近也开始一道一道的给大家讲解这些面试常考算法题，并且都是**画图+ACM模式**，如果遇到让你也写输入输出的话，那一定要把阿Q分享的这些题目学一学，**既学思路也学输入输出**，**这样你就不会在面试中的手撕算法手忙脚乱**。

当然了，主页还是有很多面经等着你去学呢



### 问题描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![image-20231222225330685](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015648.png)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![image-20231222225418378](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015170.png)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

### 思路

这里给大家讲最经典的双指针法。

1. 如果链表为空或者只有一个节点，直接返回头结点head。
2. 初始化 pre 为 nullptr，cur 为头结点 head，node 为 cur 的下一个节点。
3. 在循环中，不断更新 pre、cur 和 node 的值，使得 cur 的 next 指向 pre，然后将 pre、cur 和 node 分别向后移动一位。
4. 当 cur 移动到链表末尾时，pre 就是反转后的新头结点。

演示过程：

初始状态：

![image-20231222230442370](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015589.png)

第一步：

先定义一个空节点并初始化为nullptr，分别将这两个指针指向这个空节点和头结点，再定义一个节点用来临时存放节点。

`ListNode* pre = nullptr; // 初始化 pre 为 nullptr`

`ListNode* cur = head; // 初始化 cur 为头结点`

` ListNode* node = nullptr; // 初始化 node 为 nullptr`

![image-20231223004348408](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015361.png)

第二步：

`node = cur->next; // 保存当前节点的下一个节点`

`cur->next = pre; // 当前节点的 next 指向 pre，完成反转`

![image-20231223000122689](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015640.png)



第三步：

`pre = cur; // 更新 pre`
`cur = node; // 更新 cur`

![image-20231223000233968](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015157.png)

到这里，其实我们就可以使用一个循环，让继续这两步操作。不过为了大家更加看明白，我就将这个示例画完吧。

第四步：

`node = cur->next; // 保存当前节点的下一个节点`

`cur->next = pre; // 当前节点的 next 指向 pre，完成反转`

![image-20231223000701989](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015100.png)



第五步：

`pre = cur; // 更新 pre`
`cur = node; // 更新 cur`

![image-20231223000852894](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015614.png)

第六步：

`node = cur->next; // 保存当前节点的下一个节点`

`cur->next = pre; // 当前节点的 next 指向 pre，完成反转`

![image-20231223001018283](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120015101.png)

第七步：

`pre = cur; // 更新 pre`
`cur = node; // 更新 cur`

![image-20231223001110399](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120016095.png)

第八步：

`node = cur->next; // 保存当前节点的下一个节点`

`cur->next = pre; // 当前节点的 next 指向 pre，完成反转`

![image-20231223001212337](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120016552.png)

第九步：

`pre = cur; // 更新 pre`
`cur = node; // 更新 cur`

![image-20231223001331413](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120016839.png)

第十步：

`node = cur->next; // 保存当前节点的下一个节点`

`cur->next = pre; // 当前节点的 next 指向 pre，完成反转`

![image-20231223001505874](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120016473.png)

第十一步：

`pre = cur; // 更新 pre`
`cur = node; // 更新 cur`

![image-20231223001557268](https://raw.githubusercontent.com/aqinzz/Pictures/main/202401120016426.png)

此时cur==nullptr，退出循环。

### 参考代码

```
#include <iostream>

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head; // 如果链表为空或者只有一个节点，直接返回头结点
        }

        ListNode* pre = nullptr; // 初始化 pre 为 nullptr
        ListNode* cur = head; // 初始化 cur 为头结点
        ListNode* node = nullptr; // 初始化 node 为 nullptr

        while (cur != nullptr) {
            node = cur->next; // 保存当前节点的下一个节点
            cur->next = pre; // 当前节点的 next 指向 pre，完成反转
            pre = cur; // 更新 pre
            cur = node; // 更新 cur
        }

        return pre; // pre 就是反转后的新头结点
    }
};

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);

    Solution solution;
    ListNode* newHead = solution.reverseList(head);

    while (newHead != nullptr) {
        std::cout << newHead->val << " ";
        newHead = newHead->next;
    }

    return 0;
}
```

